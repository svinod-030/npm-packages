(function(s,n){typeof exports=="object"&&typeof module<"u"?module.exports=n():typeof define=="function"&&define.amd?define(n):(s=typeof globalThis<"u"?globalThis:s||self,s["workflow-composer"]=n())})(this,function(){"use strict";var h=Object.defineProperty;var r=(s,n,t)=>n in s?h(s,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[n]=t;var i=(s,n,t)=>r(s,typeof n!="symbol"?n+"":n,t);class s{constructor(){i(this,"steps");i(this,"context");i(this,"history");i(this,"isRunning");i(this,"runningStep");this.steps=new Map,this.context={},this.history=[],this.isRunning=!1,this.runningStep="init"}addStep(t,e,o){if(typeof t!="string"||typeof e!="function"||typeof o!="function")throw new Error("Invalid step name or functions");this.steps.set(t,{stepFn:e,rollbackFn:o})}async run(){if(this.isRunning)throw new Error("Already running");this.isRunning=!0;try{for(;this.runningStep&&this.steps.has(this.runningStep);){const t=this.steps.get(this.runningStep);this.history.push(this.runningStep);const e=await t.stepFn(this.context);this.runningStep=e||null}return this.isRunning=!1,this.context}catch(t){throw await this.rollback(),this.isRunning=!1,t}}async rollback(){for(;this.history.length>0;){const t=this.history.pop();await this.steps.get(t).rollbackFn(this.context)}}reset(){this.steps=new Map,this.context={},this.history=[],this.isRunning=!1,this.runningStep="init"}}return s});
